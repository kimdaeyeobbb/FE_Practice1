// 실행 컨텍스트를 이해하면 좋은 점
// JS가 스코프를 기반으로 식별자에 바인딩된 값을 관리하는 방식을 알게됨
// 호이스팅이 발생하는 이유에 대해 알게됨
// 테스크 큐와 함께 동작하는 이벤트 핸들러와 비동기 처리 동작 방식을 이해할 수 있게 됨

// 전역 코드
/* var 키워드로 선언된 전역 변수 및 함수 선언문으로 정의된 전역 함수를 
전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 함

이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성됨
*/

/*
함수 코드
- 지역 스코프를 생성하고 지역변수, 매개변수, arguments 객체를 관리해야 함
- 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 함
(이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됨)
*/

/*
eval 코드는 strict mode에서 자신만의 독자적인 스코프를 생성함
-> 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성됨
*/

/* 
모듈 코드
- 모듈별로 독립적인 모듈 스코프를 생성함
-> 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성됨

*/

/* 
모든 소스코드는 실행에 앞서 평가 과정을 거치며 실행하기 위한 준비를 함
*/

/* 
소스코드 평과과정

- 실행 컨텍스트 생성
- 변수, 함수 등 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는
스코프(lexical environment의 environment record)에 등록함
- 소스코드 평가과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행되기 시작함
(런타임이 시작됨.)
- 이때 소스코드 실행에 필요한 정보인 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서
검색해서 취득함
- 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록됨

*/

// var x;
// x = 1;
// // 1. 소스코드 평가 과정에서 변수 선언문 var x;를 실행
// // 2. 생성된 변수 식별자 x는 실행 컨텍스트가 관리하는 스코프에 등록되고 undefined로 초기화됨

const x = 1;
const y = 2;

function foo(a) {
  const x = 10;
  const y = 20;

  console.log(a + x + y); // 130
}

foo(100);

console.log(x + y); // 3
