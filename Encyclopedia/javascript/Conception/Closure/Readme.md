# 클로저

- '중단하다', '폐쇄하다' 라는 의미를 지니고 있음

<br>

## 함수 스코프

- js에서는 함수 스코프가 존재
- 함수 내부에서 정의된 변수의 경우 함수 어느 부분에서든 접근할 수 있음<br>
  (즉, 내부 함수에서 자신을 포함하는 외부 함수의 스코프에 접근할 수 있다는 뜻)

- [예시](./closure1.js)

<br>

## 내부 함수가 외부 함수보다 오래 살아 있는 경우에, 외부함수에 있던 변수들은 어떻게 될까?

- 내부 함수가 외부 함수보다 오래 살아있는 경우란,

```js
var outer = function () {
  // 1) ouert 함수 실행시
  var a = 1; // 2) a라는 변수가 선언됨

  var inner = function () {
    // 3) inner 함수 선언됨
    var b = 5;
    var c = 6;

    a = a + b + c;
    console.log(a); // 12
  };

  inner(); // 4) outer함수가 inner 함수를 실행
};

outer(); // outer함수 실행시킴

/*
inner 함수에는 자기보다 상위의 부모에 접근할 수 있는 권한이 존재.
따라서 a에 접근할 수 있으므로 a=1이라는 값을 가져와서 사용할 수 있었던 것임
*/
```

와 달리

```js
var outer = function () {
  var a = 1;

  var inner = function () {
    var b = 5;
    var c = 6;

    a = a + b + c;
    console.log(a);
  };

  return inner;
};

var newInner = outer(); // newInner -> outer 함수의 실행결과

newInner(); // 12
// newInner 함수가 실행되면 outer함수가 실행된다는 뜻인데, outer 함수의 결과는 inner이다.
// 결국 newInner 함수가 실행된다는 의미는 inner 함수가 실행된다는 뜻과 동일하다
```

`return inner`을 실행해주는 것임

- newInner함수가 실행이 되고나서 -> outer함수가 실행이 됨 -> 그 다음에 inner 함수가 실행됨
- return이 보이면 outer 함수의 생명이 끝나고 -> 그 다음에 inner 함수가 실행됨
- 이 케이스가 내부 함수가 외부 함수보다 오래 살아있는 경우임

### inner는 outer가 이미 반환된 후에도 outer의 a에 대한 접근 권한을 가진다

- 바로 함수는 자신을 포함하는 함수의 스코프에 접근할 수 있기 때문이다
- 따라서 outer 함수가 메모리에서 해제 되었지만 inner함수는 여전히 outer 함수의 a라는 변수에 대한 접근권한을 가지고 있다.
  따라서 a 변수는 메모리에서 해제되고 있지 않은 상태이다.

# 클로저

- 클로저를 한마디로 표현한다면 `폐쇄된 공간에 대한 접근권한을 가진 함수`를 뜻함
- 위의 inner 함수가 클로저에 해당

- 클로저의 이러한 특징을 이용한다면 비공개 데이터를 가진 객체를 만들어 볼 수 있음<br>
  (외부에서 아무리 접근을 하려고 해도 절대로 접근을 할 수 있는 private한 공간을 만들 수 있다)

- [예제](./closure3.js)

# 정리

- 자바스크립트는 내부 함수에서 자신을 포함하는 외부 함수의 스코프에 접근할 수 있다
- 내부 함수가 살아있는 상태에서 외부 함수가 파괴되면 외부 함수의 변수들에 대한 접근 권한은 내부 함수만 가지게 됨
- 클로저: `폐쇄된 공간에 대한 접근 권한을 가진 함수`
